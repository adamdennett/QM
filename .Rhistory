# Add color legend
magma_scale.add_to(m)
# Save map
m.save("interactive_school_map.html")
import geopandas as gpd
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from matplotlib.colors import Normalize
import contextily as ctx
# Reproject to Web Mercator for contextily
sf_df_mercator = sf_df_bng.to_crs(epsg=3857)
# Scale marker size
min_val = sf_df_mercator['TOTPUPS'].min()
max_val = sf_df_mercator['TOTPUPS'].max()
sf_df_mercator['size_scale'] = 4 + (sf_df_mercator['TOTPUPS'] - min_val) * (12 - 4) / (max_val - min_val)
# Color mapping
norm = Normalize(vmin=sf_df_mercator['ATT8SCR'].min(), vmax=sf_df_mercator['ATT8SCR'].max())
cmap = plt.colormaps['magma']
sf_df_mercator['color'] = sf_df_mercator['ATT8SCR'].apply(lambda x: cmap(norm(x)))
# Plot
fig, ax = plt.subplots(figsize=(10, 10))
sf_df_mercator.plot(ax=ax, color=sf_df_mercator['color'], markersize=sf_df_mercator['size_scale']**2, alpha=0.8)
# Add basemap
ctx.add_basemap(ax, source=ctx.providers.CartoDB.Positron)
# Final touches
ax.set_title("Static Map of Schools Colored by ATT8SCR and Sized by TOTPUPS", fontsize=14)
ax.set_axis_off()
# Colorbar
sm = cm.ScalarMappable(cmap=cmap, norm=norm)
sm.set_array([])
cbar = fig.colorbar(sm, ax=ax, orientation='vertical', fraction=0.03, pad=0.01)
cbar.set_label('ATT8SCR', fontsize=12)
plt.tight_layout()
plt.savefig("static_school_map_with_basemap.png", dpi=300)
plt.show()
#| echo: true
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
# Load your data into a DataFrame named england_filtered
# england_filtered = pd.read_csv("your_data.csv")
# Apply log10 transformation (replace 0s to avoid log(0))
england_filtered['log_PTFSM6CLA1A'] = np.log10(england_filtered['PTFSM6CLA1A'].replace(0, np.nan))
england_filtered['log_ATT8SCR'] = np.log10(england_filtered['ATT8SCR'].replace(0, np.nan))
# Drop rows with NaNs from log(0)
england_filtered = england_filtered.dropna(subset=['log_PTFSM6CLA1A', 'log_ATT8SCR'])
# Set theme
sns.set_theme(style="darkgrid")
# Create jointplot
g = sns.jointplot(
x="log_PTFSM6CLA1A",
y="log_ATT8SCR",
data=england_filtered,
kind="reg",
truncate=False,
color="m",
height=7
)
# Label axes
g.set_axis_labels("log10(PTFSM6CLA1A)", "log10(ATT8SCR)")
plt.show()
#| echo: true
import seaborn as sns
import matplotlib.pyplot as plt
# Set the theme
sns.set_theme(style="darkgrid")
# Create side-by-side histograms
fig, axes = plt.subplots(1, 2, figsize=(14, 6))
# Histogram for PTFSM6CLA1A
sns.histplot(data=england_filtered, x="PTFSM6CLA1A", ax=axes[0], kde=True, color="skyblue")
axes[0].set_title("Histogram of PTFSM6CLA1A")
axes[0].set_xlabel("PTFSM6CLA1A")
axes[0].set_ylabel("Frequency")
# Histogram for ATT8SCR
sns.histplot(data=england_filtered, x="ATT8SCR", ax=axes[1], kde=True, color="salmon")
axes[1].set_title("Histogram of ATT8SCR")
axes[1].set_xlabel("ATT8SCR")
axes[1].set_ylabel("Frequency")
plt.tight_layout()
plt.show()
import numpy as np
import statsmodels.api as sm
# Log-transform the variables
camden_sub['log_ATT8SCR'] = np.log(camden_sub['ATT8SCR'])
camden_sub['log_PTFSM6CLA1A'] = np.log(camden_sub['PTFSM6CLA1A'])
# Define independent and dependent variables
X = sm.add_constant(camden_sub['log_PTFSM6CLA1A'])  # adds intercept
y = camden_sub['log_ATT8SCR']
# Fit the model
camden_model1 = sm.OLS(y, X).fit()
#camden_summary = extract_model_summary(camden_model1, 'Camden Model')
# Print summary
print(camden_model1.summary())
import numpy as np
import statsmodels.api as sm
# Log-transform safely: replace non-positive values with NaN
leeds_sub['log_ATT8SCR'] = np.where(leeds_sub['ATT8SCR'] > 0, np.log(leeds_sub['ATT8SCR']), np.nan)
leeds_sub['log_PTFSM6CLA1A'] = np.where(leeds_sub['PTFSM6CLA1A'] > 0, np.log(leeds_sub['PTFSM6CLA1A']), np.nan)
# Drop rows with NaNs in either column
leeds_clean = leeds_sub.dropna(subset=['log_ATT8SCR', 'log_PTFSM6CLA1A'])
# Define independent and dependent variables
X = sm.add_constant(leeds_clean['log_PTFSM6CLA1A'])  # adds intercept
y = leeds_clean['log_ATT8SCR']
# Fit the model
leeds_model1 = sm.OLS(y, X).fit()
#leeds_summary = extract_model_summary(leeds_model1, 'Leeds Model')
# Print summary
print(leeds_model1.summary())
import pandas as pd
results_table = summary_col(
results=[camden_model1, leeds_model1, england_model1],
model_names=['Camden Model', 'Leeds Model', 'England Model'],
stars=True,
float_format="%0.3f",
# You can customize what model statistics show up here (like R2, N, F-stat)
info_dict={'N':lambda x: "{0:d}".format(int(x.nobs)),
'R-squared':lambda x: "{:.3f}".format(x.rsquared),
'Adj. R-squared':lambda x: "{:.3f}".format(x.rsquared_adj)}
)
#
# # Round for readability
print(results_table)
import numpy as np
import statsmodels.api as sm
# Log-transform safely: replace non-positive values with NaN
england_filtered['log_ATT8SCR'] = np.where(england_filtered['ATT8SCR'] > 0, np.log(england_filtered['ATT8SCR']), np.nan)
england_filtered['log_PTFSM6CLA1A'] = np.where(england_filtered['PTFSM6CLA1A'] > 0, np.log(england_filtered['PTFSM6CLA1A']), np.nan)
# Drop rows with NaNs in either column
england_clean = england_filtered.dropna(subset=['log_ATT8SCR', 'log_PTFSM6CLA1A'])
# Define independent and dependent variables
X = sm.add_constant(england_clean['log_PTFSM6CLA1A'])  # adds intercept
y = england_clean['log_ATT8SCR']
# Fit the model
england_model1 = sm.OLS(y, X).fit()
#england_summary = extract_model_summary(england_model1, 'England Model')
# Print summary
print(england_model1.summary())
import pandas as pd
results_table = summary_col(
results=[camden_model1, leeds_model1, england_model1],
model_names=['Camden Model', 'Leeds Model', 'England Model'],
stars=True,
float_format="%0.3f",
# You can customize what model statistics show up here (like R2, N, F-stat)
info_dict={'N':lambda x: "{0:d}".format(int(x.nobs)),
'R-squared':lambda x: "{:.3f}".format(x.rsquared),
'Adj. R-squared':lambda x: "{:.3f}".format(x.rsquared_adj)}
)
#
# # Round for readability
print(results_table)
results_table = summary_col(
results=[camden_model1, leeds_model1, england_model1],
model_names=['Camden Model', 'Leeds Model', 'England Model'],
stars=True,
float_format="%0.3f",
# You can customize what model statistics show up here (like R2, N, F-stat)
info_dict={'N':lambda x: "{0:d}".format(int(x.nobs)),
'R-squared':lambda x: "{:.3f}".format(x.rsquared),
'Adj. R-squared':lambda x: "{:.3f}".format(x.rsquared_adj)}
)
import pandas as pd
import statsmodels.api as sm
results_table = summary_col(
results=[camden_model1, leeds_model1, england_model1],
model_names=['Camden Model', 'Leeds Model', 'England Model'],
stars=True,
float_format="%0.3f",
# You can customize what model statistics show up here (like R2, N, F-stat)
info_dict={'N':lambda x: "{0:d}".format(int(x.nobs)),
'R-squared':lambda x: "{:.3f}".format(x.rsquared),
'Adj. R-squared':lambda x: "{:.3f}".format(x.rsquared_adj)}
)
from statsmodels.iolib.summary2 import summary_col
results_table = summary_col(
results=[camden_model1, leeds_model1, england_model1],
model_names=['Camden Model', 'Leeds Model', 'England Model'],
stars=True,
float_format="%0.3f",
# You can customize what model statistics show up here (like R2, N, F-stat)
info_dict={'N':lambda x: "{0:d}".format(int(x.nobs)),
'R-squared':lambda x: "{:.3f}".format(x.rsquared),
'Adj. R-squared':lambda x: "{:.3f}".format(x.rsquared_adj)}
)
print(results_table)
#| message: false
#| warning: false
#| include: false
## Notes - make sure that reticulate is pointing to a local reticulate install of python or things might go squiffy.
## in terminal type: where python - to find out where reticulate might have stashed a version of the python.exe
## make sure you point to it before installing these packages using:
## reticulate::use_python("C:/Path/To/Your/Python/python.exe", required = TRUE)
library(reticulate)
#reticulate::virtualenv_remove("r-reticulate")
# point reticulate to the right python installation - ideally the one reticulate installed.
#reticulate::use_python("C:/Users/Adam/AppData/Local/R/cache/R/reticulate/uv/cache/archive-v0/EiTNi4omakhlev5ckz2WP/Scripts/python.exe", required = TRUE)
#virtualenv_create("r-reticulate", python = "C:/Users/Adam/AppData/Local/R/cache/R/reticulate/uv/cache/archive-v0/EiTNi4omakhlev5ckz2WP/Scripts/python.exe")
#virtualenv_install("r-reticulate", packages = c("pyyaml", "jupyter", "statsmodels","pyjanitor","pathlib","matplotlib","pandas", "numpy", "scipy", "seaborn", "geopandas", "folium", "branca"))
#use_virtualenv("r-reticulate", required = TRUE)
# reticulate::py_config()
# reticulate::py_require("pyyaml")
# reticulate::py_require("jupyter")
# reticulate::py_require("statsmodels")
# reticulate::py_require("pandas")
# reticulate::py_require("numpy")
# reticulate::py_require("pyjanitor")
# reticulate::py_require("pathlib")
# reticulate::py_require("matplotlib")
# reticulate::py_require("seaborn")
#reticulate::py_install("folium")
#reticulate::py_install("geopandas")
#reticulate::py_install("contextily", pip = TRUE)
#reticulate::py_install("scikit-learn", pip = TRUE)
reticulate::repl_python()
#| message: false
#| warning: false
library(tidyverse)
library(janitor)
library(readr)
library(dplyr)
library(here)
# Read CSV file
edubase_schools <- read_csv("https://www.dropbox.com/scl/fi/fhzafgt27v30lmmuo084y/edubasealldata20241003.csv?rlkey=uorw43s44hnw5k9js3z0ksuuq&raw=1") %>%
clean_names() %>%
mutate(urn = as.character(urn))
#str(r_edubase_schools)
# Define base path and common NA values - NOTE YOU WILL NEED TO DOWNLOAD THIS DATA AND PUT INTO YOUR OWN base_path LOCATION ON YOUR MACHINE
base_path <- here("sessions", "L6_data", "Performancetables_130242", "2022-2023")
na_common <- c("", "NA", "SUPP", "NP", "NE")
na_extended <- c(na_common, "SP", "SN")
na_attainment <- c(na_extended, "LOWCOV", "NEW")
na_mats <- c(na_common, "SUPPMAT")
na_all <- c("", "NA", "SUPP", "NP", "NE", "SP", "SN", "LOWCOV", "NEW", "SUPPMAT")
# Absence data
england_abs <- read_csv(file.path(base_path, "england_abs.csv"), na = na_all) |>
mutate(URN = as.character(URN))
# Other School Census data
england_census <- read_csv(file.path(base_path, "england_census.csv"), na = na_all) |>
mutate(URN = as.character(URN)) |>
mutate(across(5:23, ~ parse_number(as.character(.))))
# KS4 MATs performance data
#First read
england_ks4_mats_performance <- read_csv(
file.path(base_path, "england_ks4-mats-performance.csv"),
na = na_all
) |>
mutate(
TRUST_UID = as.character(TRUST_UID),
P8_BANDING = as.character(P8_BANDING),
INSTITUTIONS_INMAT = as.character(INSTITUTIONS_INMAT)
)
# Then Identify columns to convert (excluding character columns)
cols_to_convert <- england_ks4_mats_performance |>
select(-(1:10), -P8_BANDING, -INSTITUTIONS_INMAT) |>
names()
# Then apply parse_number safely to convert characters to numbers
england_ks4_mats_performance <- england_ks4_mats_performance |>
mutate(across(all_of(cols_to_convert), ~ parse_number(as.character(.))))
# KS4 pupil destination data
england_ks4_pupdest <- read_csv(file.path(base_path, "england_ks4-pupdest.csv"), na = na_all) |>
mutate(URN = as.character(URN)) |>
mutate(across(8:82, ~ parse_number(as.character(.))))
# KS4 final attainment data
england_ks4final <- read_csv(file.path(base_path, "england_ks4final.csv"), na = na_all) |>
mutate(URN = as.character(URN)) |>
mutate(across(TOTPUPS:PTOTENT_E_COVID_IMPACTED_PTQ_EE, ~ parse_number(as.character(.))))
# School information data
england_school_information <- read_csv(
file.path(base_path, "england_school_information.csv"),
na = na_all,
col_types = cols(
URN = col_character(),
OFSTEDLASTINSP = col_date(format = "%d-%m-%Y")
)
)
reticulate::repl_python()
#| warning: false
# Left join england_ks4final with england_abs
england_school_2022_23 <- england_ks4final %>%
left_join(england_abs, by = "URN") %>%
left_join(england_census, by = "URN") %>%
left_join(england_school_information, by = "URN") %>%
left_join(edubase_schools, by = c("URN" = "urn"))
reticulate::repl_python()
#| echo: true
#| warning: false
median_value <- median(england_school_2022_23$ATT8SCR, na.rm = TRUE)
mean_value   <- mean(england_school_2022_23$ATT8SCR, na.rm = TRUE)
sd_value   <- sd(england_school_2022_23$ATT8SCR, na.rm = TRUE)
ggplot(england_school_2022_23, aes(x = ATT8SCR)) +
geom_histogram(aes(y = ..density..), binwidth = 1, fill = "#4E3C56", alpha = 0.4) +
stat_function(fun = dnorm, args = list(mean = mean_value, sd = sd_value), color = "#2E6260", linewidth = 1) +
geom_vline(xintercept = median_value, color = "black", linetype = "dotted", size = 1) +
geom_vline(xintercept = mean_value, color = "#F9DD73", linetype = "solid", size = 1) +
annotate("text",
x = median_value, y = Inf,
label = paste0("Median = ", round(median_value, 1)),
vjust = 1.3, color = "black", size = 3.5) +
annotate("text",
x = mean_value, y = Inf,
label = paste0("Mean = ", round(mean_value, 1)),
vjust = 30.5, color = "#F9DD73", size = 3.5) +
scale_y_continuous(expand = expansion(mult = c(0, 0.08))) +
labs(
title = "Attainment 8 - All Schools England and Wales, 2022/23 Academic Year",
x = "Attainment 8 Score",
y = "Density"
) +
theme_minimal()
reticulate::repl_python()
#| warning: false
ggplot(england_school_2022_23, aes(x = ATT8SCR, y = "")) +
geom_boxplot(fill = "#EDD971", alpha = 0.3, outlier.shape = NA) +
geom_jitter(aes(colour = MINORGROUP), height = 0.2, alpha = 0.3, size = 1) +
scale_colour_viridis_d(option = "turbo") +  # applies the default casaviz discrete palette
labs(
title = "Attainment 8 - All Schools 2022/23 Academic Year",
x = "Attainment 8 Score",
y = NULL,
colour = "School Type"
) +
theme_minimal() +
theme(
legend.position = "bottom",
legend.key.size = unit(10, "mm"),   # increase dot space
legend.text = element_text(size = 10)  # optional: larger legend labels
) + guides(colour = guide_legend(override.aes = list(size = 4)))
reticulate::repl_python()
# Filter data
england_filtered <- england_school_2022_23 %>%
filter(!MINORGROUP %in% c("Special school", "Independent school", "College", NA)) %>%
filter(phase_of_education_name == "Secondary") %>%
filter(establishment_status_name == "Open") %>%
select(URN, SCHNAME.x, TOWN.x, TOTPUPS, ATT8SCR, OFSTEDRATING, MINORGROUP, PTFSM6CLA1A)
#| include: false
# Filter data
england_filtered <- england_school_2022_23 %>%
filter(!MINORGROUP %in% c("Special school", "Independent school", "College", NA)) %>%
filter(phase_of_education_name == "Secondary") %>%
filter(establishment_status_name == "Open") %>%
select(URN, SCHNAME.x, LEA, LANAME, TOWN.x,gor_name, TOTPUPS, ATT8SCR, ATT8SCRENG, ATT8SCRMAT,ATT8SCRMAT,ATT8SCR_FSM6CLA1A,ATT8SCR_FSM6CLA1A,ATT8SCR_NFSM6CLA1A,ATT8SCR_BOYS,ATT8SCR_GIRLS,P8MEA,P8MEA_FSM6CLA1A,P8MEA_NFSM6CLA1A,PTFSM6CLA1A,PTNOTFSM6CLA1A,PNUMEAL,PNUMENGFL,PTPRIORLO,PTPRIORHI,NORB,NORG,PNUMFSMEVER,PERCTOT,PPERSABS10,SCHOOLTYPE.x,RELCHAR,ADMPOL.y,gender_name,OFSTEDRATING, MINORGROUP, easting, northing)
reticulate::repl_python()
#| include: false
camden_sub <- england_filtered %>%
filter(LANAME == "Camden")
leeds_sub <- england_filtered %>%
filter(LANAME == "Leeds")
reticulate::repl_python()
#| warning: false
library(ggplot2)
library(dplyr)
# Combine the datasets and label them
combined_data <- bind_rows(
camden_sub %>% mutate(Area = "Camden"),
leeds_sub %>% mutate(Area = "Leeds")
)
# Create faceted scatter plot
ggplot(combined_data, aes(x = PTFSM6CLA1A, y = ATT8SCR)) +
geom_point(alpha = 0.7, size = 3, color = "steelblue") +
facet_wrap(~ Area) +
labs(
title = "Attainment 8 vs % Disadvantaged by Local Authority",
x = "% KS4 Pupils Disadvantaged (PTFSM6CLA1A)",
y = "Attainment 8 Score (ATT8SCR)"
) +
theme_minimal()
reticulate::repl_python()
#| message: false
#| warning: false
library(sf)
library(leaflet)
library(dplyr)
library(scales)
library(viridis)
# Convert to sf object with EPSG:27700
sf_df <- st_as_sf(leeds_sub, coords = c("easting", "northing"), crs = 27700)
# Transform to EPSG:4326
sf_df <- st_transform(sf_df, crs = 4326)
# Extract lat/lon for leaflet
sf_df <- sf_df %>%
mutate(
lon = st_coordinates(.)[,1],
lat = st_coordinates(.)[,2]
)
# Define size and color scales
size_scale <- rescale(sf_df$TOTPUPS, to = c(1, 15))  # radius from 4 to 12
# Create a color palette based on ATT8SCR
pal <- colorNumeric(palette = "magma", domain = sf_df$ATT8SCR)
leaflet(sf_df) %>%
addProviderTiles("CartoDB.Positron") %>%
addCircleMarkers(
lng = ~lon,
lat = ~lat,
radius = size_scale,
stroke = FALSE,
fillOpacity = 0.8,
color = ~pal(ATT8SCR),
popup = ~paste0(
"<strong>", SCHNAME.x, "</strong><br>",
"Pupils: ", TOTPUPS
)
) %>%
addLegend(
"bottomright",
pal = pal,
values = ~ATT8SCR,
title = "ATT8SCR",
opacity = 0.8
)
reticulate::repl_python()
#| warning: false
library(ggside)
library(ggplot2)
ggplot(england_filtered, aes(x = log10(PTFSM6CLA1A), y = log10(ATT8SCR), colour = gor_name)) +
geom_point(alpha = 0.5, size = 2) +
geom_xsidedensity(aes(y = after_stat(density)), alpha = 0.5, size = 1, position = "stack") +
geom_ysidedensity(aes(x = after_stat(density)), alpha = 0.5, size = 1, position = "stack") +
theme(ggside.panel.scale.x = 0.4,ggside.panel.scale.y = 0.4)
reticulate::repl_python()
#| warning: false
library(ggplot2)
library(dplyr)
# Histogram for PTFSM6CLA1A
ggplot(england_filtered, aes(x = PTFSM6CLA1A)) +
geom_histogram(binwidth = 1, fill = "skyblue", color = "white", alpha = 0.5) +
geom_density(aes(y = ..count..), color = "skyblue", size = 1) +
theme_minimal() +
labs(
title = "Histogram of PTFSM6CLA1A",
x = "PTFSM6CLA1A",
y = "Frequency"
)
# Histogram for ATT8SCR
ggplot(england_filtered, aes(x = ATT8SCR)) +
geom_histogram(binwidth = 1, fill = "salmon", color = "white", alpha = 0.5) +
geom_density(aes(y = ..count..), color = "salmon", size = 1) +
theme_minimal() +
labs(
title = "Histogram of ATT8SCR",
x = "ATT8SCR",
y = "Frequency"
)
#| warning: false
ggplot(england_filtered, aes(x = PTFSM6CLA1A, y = ATT8SCR, fill = gor_name)) +
geom_violin(
position = position_dodge(width = 0.8),
alpha = 0.6,
draw_quantiles = c(0.25, 0.5, 0.75)
) +
facet_wrap(~ gor_name) +
theme_minimal() +
labs(
title = "Violin Plot of Attainment 8 Score with Quantiles by Region",
x = "% Disadvantaged",
y = "Attainment 8 Score",
fill = "Region"
)
#| warning: false
library(ggdist)
ggplot(england_filtered, aes(x = PTFSM6CLA1A, y = gor_name, fill = gor_name)) +
stat_slab(aes(thickness = after_stat(pdf*n)), scale = 0.7) +
stat_dotsinterval(side = "bottom", scale = 1, slab_linewidth = NA) +
scale_fill_brewer(palette = "Set2") +
theme_ggdist() +
labs(
title = "Rain Cloud Plot of % Disadvantage in Schools by Region",
x = "% Disadvantaged",
y = "Region",
fill = "Region"
)
reticulate::repl_python()
# Fit linear model and get predicted values
camden_model1 <- lm(log(ATT8SCR) ~ log(PTFSM6CLA1A), data = camden_sub)
summary(camden_model1)
reticulate::repl_python()
# Fit linear model and get predicted values
leeds_model1 <- lm(log(ATT8SCR) ~ log(PTFSM6CLA1A), data = leeds_sub)
summary(leeds_model1)
reticulate::repl_python()
# Fit linear model and get predicted values
england_filtered_clean <- england_filtered[
!is.na(england_filtered$ATT8SCR) &
!is.na(england_filtered$PTFSM6CLA1A) &
england_filtered$ATT8SCR > 0 &
england_filtered$PTFSM6CLA1A > 0,
]
england_model1 <- lm(log(ATT8SCR) ~ log(PTFSM6CLA1A), data = england_filtered_clean)
summary(england_model1)
reticulate::repl_python()
library(jtools)
export_summs(camden_model1, leeds_model1, england_model1, error_format = "", error_pos = "same", model.names = c("Camden Model", "Leeds Model", "England Model"))
exp(6.12)
exp(4.4778)
reticulate::repl_python()
exp(6.121)
exp(4.547)
exp(4.478)
exp(-0.578)
library(performance)
install.packages("performance")
install.packages("easystats")
library(performance)
check_model(england_model1,
check = c("linearity"))
check_model(england_model1,
check = c("homogeneity"))
check_model(england_model1,
check = c("qq"))
check_model(england_model1,
check = c("outliers"))
reticulate::repl_python()
